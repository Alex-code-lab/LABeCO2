------------------------------------------------
-------------- Les choses à faire --------------
------------------------------------------------
1. Ajouter les calcules et les diagrammes pour les consommables pour le massique.
        - les diagrames à quoi doivent ils ressembler? 
                - camebert en proportion consommable individuellement
                - Cammembert fonction code NACRES
                - Différence entre quantité CO2 prix vs quantité CO2 massique. 
2. Identifier top 50 NACRES (Cathie ou Kolante)
4. Changer et ajouter graphs avec masse.
5. Ajouter une barre d'incertitude sur tous les grpahs (en barre) et faire le calcul en amont. La colonne uncertainty existe déjà et je l'ai faite pour la consommation massique.
6. Faire en sorte que . ou , soient traités pareils (dans machine notamment)
7. lors de la modification des véhicules (train) j'ai la date qui ne devrait pas apparaitre et 
ça me mets que j'ai pas une bonne valeur valide si j'ai un point ou une virgule??



Axes d’amélioration

1. Réduction de la duplication de code
	•	Exemple : Les fonctions comme calculate_emission et recalculate_emissions partagent beaucoup de logique. Même si leur but est légèrement différent, elles pourraient bénéficier d’une abstraction commune.
	•	Solution possible : Créer une fonction utilitaire pour centraliser la logique de recherche des facteurs d’émission, calcul des incertitudes, etc.

2. Lisibilité
	•	Certaines fonctions sont longues et mélangent plusieurs responsabilités (ex. calculate_emission ou modify_selected_calculation).
	•	Solution possible :
	•	Fractionner ces fonctions en sous-fonctions comme fetch_emission_factors, calculate_price_based_emissions, calculate_mass_based_emissions pour clarifier leur rôle.

3. Amélioration de la gestion des données
	•	Problème : Les calculs reposent sur des manipulations directes de pandas.DataFrame (via des masques). Ces opérations sont répétées dans plusieurs fonctions.
	•	Solution possible :
	•	Créer une classe ou un module spécifique pour encapsuler la logique de manipulation des données, avec des méthodes comme get_emission_factor, get_material_data, etc.

4. Encapsulation et séparation des responsabilités
	•	La classe MainWindow contient une grande partie de la logique métier (calculs, gestion des historiques, import/export).
	•	Solution possible : Introduire une architecture Model-View-Controller (MVC) ou Model-View-Presenter (MVP).
	•	Par exemple, un modèle dédié pour gérer les calculs et les données, tandis que MainWindow reste axée sur l’interface utilisateur.

5. Gestion des constantes
	•	Les noms des colonnes (ex. 'category', 'subcategory', 'total', etc.) et certains chemins de fichiers sont codés en dur.
	•	Solution possible : Utiliser un module ou une classe de configuration pour centraliser ces constantes. Cela simplifie la maintenance et réduit le risque d’erreurs en cas de modifications.

6. Performance
	•	Si les pandas.DataFrame deviennent volumineux, les opérations de filtrage répétées pourraient ralentir l’application.
	•	Solution possible :
	•	Cacher certains calculs intermédiaires ou utiliser des structures de données optimisées (indexation, NumPy pour certains calculs lourds).
	•	Effectuer un prétraitement des données fréquemment utilisées.

7. Tests et robustesse
	•	Problème : Il semble qu’il n’y ait pas de tests automatisés pour s’assurer que les calculs fonctionnent correctement après des modifications.
	•	Solution possible : Ajouter des tests unitaires, notamment pour les fonctions critiques (calculate_emission, recalculate_emissions, update_total_emissions).

8. Ergonomie utilisateur
	•	Exemple : Lorsqu’une erreur est levée, l’utilisateur reçoit un message mais ne bénéficie pas d’un retour visuel clair sur l’endroit où se trouve l’erreur.
	•	Solution possible :
	•	Ajouter une mise en évidence visuelle (champs rouges, etc.) en cas d’erreurs.